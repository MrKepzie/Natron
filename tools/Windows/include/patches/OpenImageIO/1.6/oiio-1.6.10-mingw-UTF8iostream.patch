diff --git a/src/include/OpenImageIO/filesystem.h b/src/include/OpenImageIO/filesystem.h
index 78732f2..b4c6c38 100644
--- a/src/include/OpenImageIO/filesystem.h
+++ b/src/include/OpenImageIO/filesystem.h
@@ -45,6 +45,7 @@
 #include <cstdio>
 #include <ctime>
 #include <fstream>
+#include <cassert>
 #include <string>
 #include <vector>
 
@@ -52,9 +53,25 @@
 #include "oiioversion.h"
 #include "string_view.h"
 
+#if defined(_WIN32) && defined(__GLIBCXX__)
+#define FILESYSTEM_USE_STDIO_FILEBUF 1
+#include "fstream_mingw.h"
+#endif
 
 OIIO_NAMESPACE_BEGIN
 
+#if FILESYSTEM_USE_STDIO_FILEBUF
+// MingW uses GCC to build, but does not support having a wchar_t* passed as argument
+// of ifstream::open or ofstream::open. To properly support UTF-8 encoding on MingW we must
+// use the __gnu_cxx::stdio_filebuf GNU extension that can be used with _wfsopen and returned
+// into a istream which share the same API as ifsteam. The same reasoning holds for ofstream.
+typedef basic_ifstream<char> ifstream;
+typedef basic_ofstream<char> ofstream;
+#else
+typedef std::ifstream ifstream;
+typedef std::ofstream ofstream;
+#endif
+
 /// @namespace Filesystem
 ///
 /// @brief Platform-independent utilities for manipulating file names,
@@ -192,16 +209,16 @@ OIIO_API FILE *fopen (string_view path, string_view mode);
 /// Return the current (".") directory path.
 ///
 OIIO_API std::string current_path ();
-
+    
 /// Version of std::ifstream.open that can handle UTF-8 paths
 ///
-OIIO_API void open (std::ifstream &stream, string_view path,
-                    std::ios_base::openmode mode = std::ios_base::in);
-
+OIIO_API void open (OIIO_NAMESPACE::ifstream &stream, string_view path,
+                        std::ios_base::openmode mode = std::ios_base::in);
+    
 /// Version of std::ofstream.open that can handle UTF-8 paths
 ///
-OIIO_API void open (std::ofstream &stream, string_view path,
-                    std::ios_base::openmode mode = std::ios_base::out);
+OIIO_API void open (OIIO_NAMESPACE::ofstream &stream, string_view path,
+                        std::ios_base::openmode mode = std::ios_base::out);
 
 /// Read the entire contents of the named text file and place it in str,
 /// returning true on success, false on failure.
diff --git a/src/libutil/filesystem.cpp b/src/libutil/filesystem.cpp
index 72096a5..e5a48b4 100644
--- a/src/libutil/filesystem.cpp
+++ b/src/libutil/filesystem.cpp
@@ -40,14 +40,19 @@
 #include <boost/foreach.hpp>
 #include <boost/regex.hpp>
 
+
 #include "OpenImageIO/dassert.h"
 #include "OpenImageIO/ustring.h"
 #include "OpenImageIO/filesystem.h"
+#include "OpenImageIO/refcnt.h"
 
 #ifdef _WIN32
 #include <windows.h>
 #include <shellapi.h>
 #include <direct.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <Share.h>
 #else
 #include <unistd.h>
 #endif
@@ -484,13 +489,13 @@ Filesystem::fopen (string_view path, string_view mode)
 }
 
 
-
 void
-Filesystem::open (std::ifstream &stream, string_view path,
+Filesystem::open (OIIO_NAMESPACE::ifstream &stream, string_view path,
                   std::ios_base::openmode mode)
 {
 #ifdef _WIN32
-    // Windows std::ifstream accepts non-standard wchar_t* 
+    // Windows std::ifstream accepts non-standard wchar_t*
+    // On MingW, we use our own OIIO_NAMESPACE::ifstream
     std::wstring wpath = Strutil::utf8_to_utf16(path);
     stream.open (wpath.c_str(), mode);
     stream.seekg (0, std::ios_base::beg); // force seek, otherwise broken
@@ -502,11 +507,12 @@ Filesystem::open (std::ifstream &stream, string_view path,
 
 
 void
-Filesystem::open (std::ofstream &stream, string_view path,
+Filesystem::open (OIIO_NAMESPACE::ofstream &stream, string_view path,
                   std::ios_base::openmode mode)
 {
 #ifdef _WIN32
     // Windows std::ofstream accepts non-standard wchar_t*
+    // On MingW, we use our own OIIO_NAMESPACE::ofstream
     std::wstring wpath = Strutil::utf8_to_utf16 (path);
     stream.open (wpath.c_str(), mode);
 #else
@@ -515,7 +521,6 @@ Filesystem::open (std::ofstream &stream, string_view path,
 }
 
 
-
 /// Read the entire contents of the named file and place it in str,
 /// returning true on success, false on failure.
 bool
@@ -523,13 +528,15 @@ Filesystem::read_text_file (string_view filename, std::string &str)
 {
     // For info on why this is the fastest method:
     // http://insanecoding.blogspot.com/2011/11/how-to-read-in-file-in-c.html
-    std::ifstream in;
+    
+    OIIO_NAMESPACE::ifstream in;
     Filesystem::open (in, filename);
+    
+    
     // N.B. for binary read: open(in, filename, std::ios::in|std::ios::binary);
     if (in) {
         std::ostringstream contents;
         contents << in.rdbuf();
-        in.close ();
         str = contents.str();
         return true;
     }
diff --git a/src/libutil/strutil.cpp b/src/libutil/strutil.cpp
index 954fd61..21e45a8 100644
--- a/src/libutil/strutil.cpp
+++ b/src/libutil/strutil.cpp
@@ -507,8 +507,9 @@ Strutil::utf8_to_utf16 (string_view str)
 {
     std::wstring native;
     
-    native.resize(MultiByteToWideChar (CP_UTF8, 0, str.c_str(), -1, NULL, 0));
-    MultiByteToWideChar (CP_UTF8, 0, str.c_str(), -1, &native[0], (int)native.size());
+    
+    native.resize(MultiByteToWideChar (CP_UTF8, 0, str.c_str(), -1, NULL, 0) -1);
+    MultiByteToWideChar (CP_UTF8, 0, str.c_str(), str.size(), &native[0], (int)native.size());
 
     return native;
 }
diff --git a/src/openexr.imageio/exrinput.cpp b/src/openexr.imageio/exrinput.cpp
index e53067f..bffc399 100644
--- a/src/openexr.imageio/exrinput.cpp
+++ b/src/openexr.imageio/exrinput.cpp
@@ -131,7 +131,7 @@ private:
         }
         return true;
     }
-    std::ifstream ifs;
+    OIIO_NAMESPACE::ifstream ifs;
 };
 
 
diff --git a/src/openexr.imageio/exroutput.cpp b/src/openexr.imageio/exroutput.cpp
index 72f66a5..6cdfe9e 100644
--- a/src/openexr.imageio/exroutput.cpp
+++ b/src/openexr.imageio/exroutput.cpp
@@ -125,7 +125,7 @@ private:
             throw Iex::ErrnoExc ("File output failed.");
         }
     }
-    std::ofstream ofs;
+    OIIO_NAMESPACE::ofstream ofs;
 };
 
 
diff --git a/src/pnm.imageio/pnminput.cpp b/src/pnm.imageio/pnminput.cpp
index 86c16f4..17abebc 100644
--- a/src/pnm.imageio/pnminput.cpp
+++ b/src/pnm.imageio/pnminput.cpp
@@ -32,6 +32,7 @@
 #include <fstream>
 #include <cstdlib>
 
+
 #include "OpenImageIO/filesystem.h"
 #include "OpenImageIO/fmath.h"
 #include "OpenImageIO/imageio.h"
@@ -53,7 +54,7 @@ private:
       P1, P2, P3, P4, P5, P6, Pf, PF
     };
 
-    std::ifstream m_file;
+    OIIO_NAMESPACE::ifstream m_file;
     std::streampos m_header_end_pos; // file position after the header
     std::string m_current_line; ///< Buffer the image pixels
     const char * m_pos;
@@ -82,7 +83,7 @@ OIIO_PLUGIN_EXPORTS_END
 
 
 inline bool
-nextLine (std::ifstream &file, std::string &current_line, const char * &pos) 
+nextLine (std::istream &file, std::string &current_line, const char * &pos)
 {   
     if (!file.good())
         return false;
@@ -96,7 +97,7 @@ nextLine (std::ifstream &file, std::string &current_line, const char * &pos)
 
 
 inline const char * 
-nextToken (std::ifstream &file, std::string &current_line, const char * &pos)
+nextToken (std::istream &file, std::string &current_line, const char * &pos)
 {		
     while (1) {
         while (isspace (*pos)) 
@@ -112,7 +113,7 @@ nextToken (std::ifstream &file, std::string &current_line, const char * &pos)
 
 
 inline const char *
-skipComments (std::ifstream &file, std::string &current_line, 
+skipComments (std::istream &file, std::string &current_line,
               const char * & pos, char comment = '#')
 {		
     while (1) {
@@ -128,7 +129,7 @@ skipComments (std::ifstream &file, std::string &current_line,
 
 
 inline bool
-nextVal (std::ifstream & file, std::string &current_line,
+nextVal (std::istream & file, std::string &current_line,
          const char * &pos, int &val, char comment = '#')
 {
     skipComments (file, current_line, pos, comment);
@@ -152,7 +153,7 @@ invert (const T *read, T *write, imagesize_t nvals)
 
 template <class T> 
 inline bool 
-ascii_to_raw (std::ifstream &file, std::string &current_line, const char * &pos,
+ascii_to_raw (std::istream &file, std::string &current_line, const char * &pos,
               T *write, imagesize_t nvals, T max)
 {
     if (max)
@@ -248,7 +249,7 @@ PNMInput::read_file_scanline (void * data, int y)
 
     std::vector<unsigned char> buf;
     bool good = true;
-    if (!m_file.is_open())
+    if (!m_file)
         return false;
     int nsamples = m_spec.width * m_spec.nchannels;
 
@@ -276,17 +277,17 @@ PNMInput::read_file_scanline (void * data, int y)
     switch (m_pnm_type) {
         //Ascii 
         case P1:
-            good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned char *) data, 
+            good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned char *) data,
                                   nsamples, (unsigned char)m_max_val);
             invert ((unsigned char *)data, (unsigned char *)data, nsamples); 
             break;
         case P2:
         case P3:
             if (m_max_val > std::numeric_limits<unsigned char>::max())
-                good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned short *) data, 
+                good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned short *) data,
                                       nsamples, (unsigned short)m_max_val);
             else 
-                good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned char *) data, 
+                good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned char *) data,
                                       nsamples, (unsigned char)m_max_val);
             break;
         //Raw
@@ -328,7 +329,7 @@ PNMInput::read_file_header ()
 
     unsigned int width, height;
     char c;
-    if (!m_file.is_open())
+    if (!m_file)
         return false;
   
     //MagicNumber
@@ -444,9 +445,8 @@ bool
 PNMInput::open (const std::string &name, ImageSpec &newspec)
 {
     close(); //close previously opened file
-
     Filesystem::open (m_file, name, std::ios::in|std::ios::binary);
-
+    
     m_current_line = "";
     m_pos = m_current_line.c_str();
 
@@ -462,8 +462,7 @@ PNMInput::open (const std::string &name, ImageSpec &newspec)
 bool
 PNMInput::close ()
 {
-    if (m_file.is_open())
-        m_file.close();
+    m_file.close();
     return true;
 }
 
diff --git a/src/pnm.imageio/pnmoutput.cpp b/src/pnm.imageio/pnmoutput.cpp
index 07735bc..e9866bb 100644
--- a/src/pnm.imageio/pnmoutput.cpp
+++ b/src/pnm.imageio/pnmoutput.cpp
@@ -51,7 +51,7 @@ public:
 
 private:
     std::string m_filename;           ///< Stash the filename
-    std::ofstream m_file;
+    OIIO_NAMESPACE::ofstream m_file;
     unsigned int m_max_val, m_pnm_type;
     unsigned int m_dither;
     std::vector<unsigned char> m_scratch;
@@ -188,10 +188,11 @@ PNMOutput::open (const std::string &name, const ImageSpec &userspec,
         m_pnm_type -= 3;
         Filesystem::open (m_file, name);
     }
-    else
+    else {
         Filesystem::open (m_file, name, std::ios::out|std::ios::binary);
+    }
 
-    if (!m_file.is_open())
+    if (!m_file)
        return false;
 
     m_max_val = (1 << bits_per_sample) - 1;
@@ -214,7 +215,7 @@ PNMOutput::open (const std::string &name, const ImageSpec &userspec,
 bool
 PNMOutput::close ()
 {
-    if (! m_file.is_open()) {   // already closed
+    if (! m_file) {   // already closed
         return true;
     }
 
@@ -237,7 +238,7 @@ bool
 PNMOutput::write_scanline (int y, int z, TypeDesc format,
         const void *data, stride_t xstride)
 {
-    if (!m_file.is_open())
+    if (!m_file)
         return false;
     if (z)
         return false;
diff --git a/src/psd.imageio/psdinput.cpp b/src/psd.imageio/psdinput.cpp
index b2c5770..e8f4d3b 100644
--- a/src/psd.imageio/psdinput.cpp
+++ b/src/psd.imageio/psdinput.cpp
@@ -196,7 +196,7 @@ private:
     };
 
     std::string m_filename;
-    std::ifstream m_file;
+    OIIO_NAMESPACE::ifstream m_file;
     //Current subimage
     int m_subimage;
     //Subimage count (1 + layer count)
@@ -543,8 +543,10 @@ bool
 PSDInput::open (const std::string &name, ImageSpec &newspec)
 {
     m_filename = name;
+    
     Filesystem::open (m_file, name, std::ios::binary);
-    if (!m_file.is_open ()) {
+    
+    if (!m_file) {
         error ("\"%s\": failed to open file", name.c_str());
         return false;
     }
@@ -759,7 +761,7 @@ void
 PSDInput::init ()
 {
     m_filename.clear ();
-    m_file.close ();
+    m_file.close();
     m_subimage = -1;
     m_subimage_count = 0;
     m_specs.clear ();
@@ -928,7 +930,7 @@ PSDInput::load_resources ()
     ImageResourceMap resources;
     std::streampos begin = m_file.tellg ();
     std::streampos end = begin + (std::streampos)length;
-    while (m_file && m_file.tellg () < end) {
+    while (!m_file.fail() && m_file.tellg () < end) {
         if (!read_resource (block) || !validate_resource (block))
             return false;
 
